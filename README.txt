Μανωλάς Σταμάτιος 1115201400094 Λειτουργικά Συστήματα Εργασία 4η

Γενικά:

	Έχω ακολουθήσει τις οδηγίες της εκφώνησης και είδα και κάποιες διορθώσεις που υπήρχαν στο φόρουμ. Το πρόγραμμα τρέχει
με την εντολή ./CFSshell. Το πρόγραμμα αποδευσμεύει τη μνήμη κανονικά. Έχω προσπαθήσει να αποφύγω διπλότυπα δεδομένα όσον 
αφορά τα αντικείμενα. Το compilation γίνεται με την εντολή make, και η make clean σβήνει τα .ο αρχεία και το εκτελέσιμο. Οι 
εντολές από το χρήστη κατά την εκτέλεση είναι ακριβώς ίδιες σε ορθογραφία όπως στην εκφώνηση μόνο που δεν ελέχγουν όλες αν 
δέχονται δεδομένα κι αν αυτά είναι σωστά. Το πρόγραμμα εχει γραφτεί σε C++. Επίσης, στις δομές προσπάθησα να ακολουθήσω 
λογική του μαύρου κουτιού και να είναι αυτόνομες. Γενικά έχω τρέξει τίς δομές αρκετά με valgrind και δε μου βγάζει κανένα 
error. Όλες οι δομές εκτός από κάποια tempς είναι δυναμικές.
Πρότυπη εντολή εκτέλεσης:
make clean && make && valgrind -v --leak-check=yes --show-leak-kinds=all --track-fds=yes --track-origins=yes ./CFSshell

Λογική Συστήματος CFS

	Τα πάντα αποτελούνται από μπλοκς με συγκεκριμένο μέγεθος που δίνεται από τη χρήστη κατάτη δημιουργία ενός CFS. Το μόνα
μπλοκ που έχει διαφορετικό μέγεθος είναι το Super Block. Έτσι, κάθε αρχείο ή φάκελος έχουν το header block όπως φαίνεται 
παρακάτω. Αρχικά, το πρώτο byte κάθε μπλοκ δείχνει αν είναι "ζωντανό". Στο header block συγκεκριμένα είναι γραμμένα τα 
MetaData, έπειτα το όνομα του entity και μετά ένας πίνακας από blockIDs που δείχνουν σε δεδομένα αν πρόκειται για αρχείο,
ή σε header block των εσωτερικών Entities αν πρόκειται για φάκελο. Το σύστημα λειτουργεί περισσότερο με τη λογική του "που
είναι" ένα αρχείο παρά με το "ποιο είναι". Το nodeid χρειάζεται λιγότερο. Τέλος, λόγω του byte που δείχνει το state του block
(alive/dead), όταν διαφράφεται ένα αρχείο απλά αλλάζει τιμή το byte αυτό. Έτσι, τα καινούργια αρχεία/φακέλοι που δημιουργούνται
γράφονται πάνω από τα είδη νεκρά χωρίς να αφήνονται κενά ή τρύπες.

MDS Block visualization

*******************************************  ---
* 1 byte, state of block (alive/dead)     *   |
* unsigned long int nodeid;               *   |
* unsigned int filenamelength;	          *   |
* unsigned int size; 			          *   |
* unsigned int type;                      *   |
* unsigned int linkCounter;				  *   |
* unsigned long int parentnodeid;         *   |
* unsigned long int parentBlockID;        *   |
* unsigned long int linksArrayBlockID;    *   |
* unsigned long int parentnodeid;         *   |
* time_t creationTime;                    *   |
* time_t accessTime;                      *   |
* time_t modificationTime;                *   |
* unsigned int numberOfBlocks;            *   |
* 									 	  *   |
* -----------------------------           *   |
* max filename bytes				      *
* ------------------------------          *   Block Size
* size of filename                        *
* blockID (pointing to Data/MDS)          *   |
* blockID (pointing to Data/MDS)          *   |
* blockID (pointing to Data/MDS)          *   |
* blockID (pointing to Data/MDS)          *   |
				. 				          	  |
				.                         	  |
				.				          	  |
* blockID (pointing to Data/MDS)          *   |
* blockID points to next set of           *   |
*	blockIDs					          *   |
*******************************************  ---

Ανάπτυξη Κώδικα:

1. cfs_workwith <FILE>
	Δουλεύει μόνο με αρχεία .cfs

2. cfs_mkdir <DIRECTORIES>
	Δουλεύει όπως αναφέρεται στην εκφώνηση.

3. cfs_touch <OPTIONS> <FILES>
	Δουλεύει όπως αναφέρεται στην εκφώνηση.

4. cfs_pwd
	Δουλεύει όπως αναφέρεται στην εκφώνηση.

5. cfs_cd <PATH>
	Αλλαγή τρέχοντος καταλόγου στο <PATH>. Γενικά για να πάει σε προήγουμενο κατάλογο πρέπει να χρησιμοποιηθεί η μονή τελεία ".",
που δείχνει άλμα στο root κατάλογο("/"), ή η διπλή τελεία "..", που δείχνει στο γονικό. Σε εσωτερικούς καταλόγους Δουλεύει 'οπως
στα Linux.

6. cfs_ls <OPTIONS> 
Εκτύπωση περιεχομένων αρχείων με τη σειρά που αποθηκεύονται στον κατάλογο.
<OPTIONS> είναι:
-l: Προβολή όλων των χαρακτηριστικών των αρχείων. Τα χαρακτηριστικά που περιλαμβάνονται είναι ο χρόνος δημιουργίας, ο χρόνος 
τελευταίας πρόσβασης, ο χρόνος τελευταίας τροποποίησης, το μέγεθος και το nodeid.
-d: Προβολή μόνο των καταλόγων.

7. cfs_cp <OPTIONS> <SOURCE> <DESTINATION> | <OPTIONS> <SOURCES> ... <DIRECTORY>
	Δεν έχει υλοποιηθεί.

8. cfs_cat <SOURCE FILES> -o <OUTPUT FILE>
	Δεν έχει υλοποιηθεί.

9. cfs_ln <SOURCE FILE> <OUTPUT FILE>
	Δεν έχει υλοποιηθεί.

10. cfs_mv <OPTIONS> <SOURCE> <DESTINATION> | <OPTIONS> <SOURCES> ... <DIRECTORY>
	Δεν έχει υλοποιηθεί.

11. cfs_rm <OPTIONS> <DESTINATIONS>
	Δουλεύει όπως αναφέρεται στην εκφώνηση, αλλά μόνο τοπικά(δηλαδή δε δουλεύει με PATH) και μπορεί να διαγράψει αρχεία εκτός
από καταλόγους.

12. cfs_import <SOURCES> ... <DIRECTORY>
	Δεν έχει υλοποιηθεί.

13. cfs_export <SOURCES> ... <DIRECTORY>
	Δεν έχει υλοποιηθεί.

14. cfs_create <OPTIONS> <FILE>. Δημιουργία ενός cfs στο αρχείο <FILE>
	-bs <BLOCK SIZE>: Καθορισμός μεγέθους μπλοκ δεδομένων σε Bytes.
	-fns <FILENAME SIZE>: Καθορισμός μεγέθους ονόματος αρχείων σε Bytes.
	Οι άλλες τιμές καθορίζονται από το μέγεθος του μπλοκ. 

Μπόνους ερώτημα:
	Κενά στο CFS αρχείο δημιουργούνται, αλλά μετέπειτα καλύπτονται με τη δημιουργία αρχείων/φακέλων. Δεν μετακινείται είτε
διαγράφεται τίποτα στο το CFS αρχείο.

14. cfs_finish
	Κλείνει το CFS αρχείο, ώστε να μπορούν να κληθούν πάλι οι cfs_create και cfs_workwith.

15. exit
	Κλείνει το πρόγραμμα.(δεν χρειάζεται να καλεστεί η cfs_finish πριν)

Επίσης δημιουργείται log file που γίνεται η καταγραφή των εντολών που έδωσε ο χρήστης.

Σημείωση: Με paths λειτουργεί μόνο η cfs_cd.